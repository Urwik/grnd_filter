  int
  run()
  {
    PointCloudI::Ptr cloud_in_intensity (new PointCloudI);
    PointCloud::Ptr cloud_in_xyz (new PointCloud);
    PointCloud::Ptr cloud_out_xyz (new PointCloud);
    PointCloud::Ptr tmp_cloud (new PointCloud);
    PointCloud::Ptr uncluster_cloud (new PointCloud);

    pcl::IndicesPtr coarse_ground_indices (new pcl::Indices);
    pcl::IndicesPtr coarse_truss_indices (new pcl::Indices);
    pcl::ModelCoefficientsPtr tmp_plane_coefss (new pcl::ModelCoefficients);

    gt_indices ground_truth_indices;
    ground_truth_indices.ground = pcl::IndicesPtr (new pcl::Indices);
    ground_truth_indices.truss = pcl::IndicesPtr (new pcl::Indices);

    vector<pcl::PointIndices> regrow_clusters;
    vector<int> valid_clusters;

    // Read pointcloud
    cloud_in_intensity = arvc::readCloudWithIntensity(this->path);
    ground_truth_indices = arvc::getGroundTruthIndices(cloud_in_intensity);
    *this->gt_ground_idx = *ground_truth_indices.ground;
    *this->gt_truss_idx = *ground_truth_indices.truss;
    this->cloud_in = arvc::parseToXYZ(cloud_in_intensity);

    // ***********************************************************************//
    // COARSE SEGMENTATITION
    // EXTRACT BIGGEST PLANE
    // This is temporal, only for get the correct biggest plane
    tmp_cloud = arvc::voxel_filter(this->cloud_in, 0.05f);

    tmp_plane_coefss = arvc::compute_planar_ransac(tmp_cloud, true, 0.5f, 1000);
    auto coarse_indices = arvc::get_points_near_plane(this->cloud_in, tmp_plane_coefss, 0.5f);
    coarse_ground_indices = coarse_indices.first;
    coarse_truss_indices = coarse_indices.second;
    


    // CHECK CLOUDS
    if(this->visualize)
    {
      PointCloud::Ptr coarse_ground_cloud (new PointCloud);
      PointCloud::Ptr coarse_truss_cloud (new PointCloud);

      coarse_ground_cloud = arvc::extract_indices(this->cloud_in, coarse_ground_indices, false);
      coarse_truss_cloud = arvc::extract_indices(this->cloud_in, coarse_truss_indices, false);
      arvc::visualizeClouds(coarse_truss_cloud, coarse_ground_cloud);
    }

    // ***********************************************************************//
    // FINE SEGMENTATION
    // FILTER CLUSTERS BY EIGEN VALUES
    std::pair<vector<pcl::PointIndices>, int> regrow_output = arvc::regrow_segmentation(this->cloud_in, coarse_ground_indices);
    // std::pair<vector<pcl::PointIndices>, int> regrow_output = arvc::regrow_segmentation(this->cloud_in);

    regrow_clusters = regrow_output.first;
    this->normals_time = regrow_output.second;

    // VALIDATE CLUSTERS FROM THEIR EIGENVALUES
    valid_clusters = arvc::validate_clusters_by_ratio(this->cloud_in, regrow_clusters, 0.3f);
    // valid_clusters = arvc::validate_clusters_by_module(this->cloud_in, regrow_clusters, 1000.0f);
    // valid_clusters = arvc::validate_clusters_hybrid(this->cloud_in, regrow_clusters, 0.3f, 1000.0f);

    for(int clus_indx : valid_clusters)
      coarse_truss_indices->insert(coarse_truss_indices->end(), regrow_clusters[clus_indx].indices.begin(), regrow_clusters[clus_indx].indices.end());


    *this->truss_idx = *coarse_truss_indices;
    *this->ground_idx = *arvc::inverseIndices(this->cloud_in, this->truss_idx);

    // FILTER CLOUD BY DENISTY
    this->truss_idx = arvc::radius_outlier_removal(this->cloud_in, this->truss_idx, 0.1f, 5, false);
    this->ground_idx = arvc::inverseIndices(this->cloud_in, this->truss_idx);



    // FINAL CLOUD
    this->cloud_out = arvc::extract_indices(this->cloud_in, this->truss_idx, false);
    // tmp_cloud = arvc::extract_indices(this->cloud_in, this->ground_idx, false);
    // (this->visualize) ?  arvc::visualizeClouds(this->cloud_out,0,0,170, tmp_cloud,0,0,170) : void();



    if(this->visualize){
      this->getConfMatrixIndexes();
      PointCloud::Ptr error_cloud (new PointCloud);
      PointCloud::Ptr truss_cloud (new PointCloud);
      PointCloud::Ptr ground_cloud (new PointCloud);
      pcl::IndicesPtr error_idx (new pcl::Indices);

      error_idx->insert(error_idx->end(), this->fp_idx->begin(), this->fp_idx->end());
      error_idx->insert(error_idx->end(), this->fn_idx->begin(), this->fn_idx->end());

      truss_cloud = arvc::extract_indices(cloud_in, this->tp_idx, false);
      ground_cloud = arvc::extract_indices(cloud_in,this->tn_idx, false);
      error_cloud = arvc::extract_indices(cloud_in, error_idx, false);

      pcl::visualization::PCLVisualizer my_vis;
      my_vis.setBackgroundColor(1,1,1);

      pcl::visualization::PointCloudColorHandlerCustom<PointT> truss_color (truss_cloud, 0,255,0);
      pcl::visualization::PointCloudColorHandlerCustom<PointT> ground_color (ground_cloud, 100,100,100);
      pcl::visualization::PointCloudColorHandlerCustom<PointT> error_color (error_cloud, 255,0,0);

      my_vis.addPointCloud(truss_cloud, truss_color, "truss_cloud");
      my_vis.addPointCloud(ground_cloud, ground_color, "wrong_cloud");
      my_vis.addPointCloud(error_cloud, error_color, "error_cloud");

      my_vis.addCoordinateSystem(0.8, "sensor_origin");
      auto pos = cloud_in->sensor_origin_;
      auto ori = cloud_in->sensor_orientation_;
      
      Eigen::Vector3f position(pos[0], pos[1], pos[2]);
      my_vis.addCube(position, ori, 0.3, 0.3, 0.3, "sensor_origin");

      while (!my_vis.wasStopped())
      {
        my_vis.spinOnce(100);
      }
    }

    auto start = std::chrono::high_resolution_clock::now();
    // Compute metrics
    if(this->compute_metrics)
    {
      this->cm = arvc::computeConfusionMatrix(this->gt_truss_idx, this->gt_ground_idx, this->truss_idx, this->ground_idx);
      this->metricas = arvc::computeMetrics(cm);
    }
    auto stop = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(stop - start);
    this->metrics_time = duration.count();

    return 0;
  }
